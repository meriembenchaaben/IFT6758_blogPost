---
layout: post
title: MileStone 1
---

## Task 1: Warm-up 
#### Question 1
**What issues do you notice by using this metric to rank goalies?**

<figure>
<img src="/assets/Milestone1_Task1_Question1.png" alt="">
<figcaption style="text-align:center;">Figure 1.1: Top goalies using saving percentage metric</figcaption>
</figure>

The top goalies, with highest save percentages (SV%), played few games without conceding goals. This metric favors goalies who played few games and faced few shots. It doesn't take into consideration the number of games played or the number of shots a goalie has faced.

Example: A goalie who faced three shots and saved them (SV%=1) would have a better save percentage than a goalie who faced 1620 shot and saved 1482 (SV%=1=0.915)

**What could be done to deal with this?**
To deal with this issue, we need to smooth the SV% metric with the number of shots a goalie has faced. We can also consider the number of games/wins of the goalie.


**The Goals Saved Above Average (GSAA)** is a metric that fairly compares goalies performance.

It measures the number of goals a particular goalie saved based on his save percentage and shots against him given the average of both of these categories across the league.
> GSAA = [Shots against x (1 – league-average save percentage)] – goals allowed 

A second option is to consider the number of games played  **(GP)** or the wins **(W)** and combine it with the save percentage **(SV%)**.
We suggest the following formula: 
> Score= SV%*W 

A high score requires that the goalie has won many games and has a good SV%. This penalizes goalies who played few games or has few wins which solves the problem seen in the first question.

#### Question 2
We present a bar plot with player names on the y-axis and save percentage (‘SV%’) on the x-axis, all filtred using our  proposed approach.  
<figure> 
<img src="/assets/Question1_2.png" alt="">
<figcaption style="text-align:center;">Figure 1.2: SV% of top goalies using the proposed approach </figcaption>
</figure>

#### Question 3


- **GP (Games Played)**: A good goalie should have played several games to avoid the bias of having a high SV% while playing few games.
 
	
- **W (Wins)**: The number of wins might be a good metric to judge the performance of goalies when coupled with other metrics.

	
- **L (Losses)**: Following the same logic explained previously, the golies could be penalized by using both *Losses* and *GA: Goals against* metrics. 	

- **SA (Shots Against)**: This metric when coupled with the save percentage could be useful for determining the performance of a goalie. A goalie with a good save percentage and a high number of shots against should have a good performance.

- **SO (Shutouts)**	: A shutout is credited to a goaltender who successfully stops the other team from scoring during the entire game. This might be an extra indicator for the performance of goalies. However, it should be used alongside with other metrics because it is the effort of the effective defensive play of the whole team although it is credited to the goaltender.

- **GPS (Goalie Point Shares)** This metric estimates the number of points contributed by a player. A good goalie should have a high contribution to the wins of his team.

- **QS (Quality Starts)** This two statistic was developed by Robert Vollman. It measures whether a goalie has played well enough to give his team a chance to win. This makes it a fair znd important measure to compare goalies performance. 

- **GSAA (Goals Saved Above Average)**	This metric is computed using the league's average save percentage with the number of shots a goalie has had. It measures how many shots does a goalie save above what an average goalie would do. It is an essential and important statistic that is widely used in Hockey to evalute the performance of goalies.



## Task 2: Data Acquisition

We encapsulated all the logics responsible of downloading the NHL play-by-play data in a class called ```NHL_API```.
When instantiated, we check in the constructor if a path to the dataset is specified, through the environment variable ```DATASET_DIR_PATH```, otherwise we assign a default value.

```python
class NHL_API:
    
    def __init__(self):
        # Load dataset directory path from .env file
        load_dotenv('../.env')
        self.DATASET_DIR_PATH = os.getenv('DATASET_DIR_PATH')

        if (not self.DATASET_DIR_PATH):
            self.DATASET_DIR_PATH = 'dataset/'
```



To retrieve the data between 2 seasons, we need to call method ```get_nhl_data``` while specifing the start and end seasons (for the season *s/s+1*, the season argument should be *s*).
The method uses ```get_nhl_season``` to retrieve the data of each season and shows the progress of retrieving the data.

In the method ```get_nhl_season```, we check if the data of a particular season already exists in local.
If it exists, it reads it from the local file and returns the results. Otherwise, it calls ```get_nhl_regular``` and ```get_nhl_playoffs``` respectively to retrieve the data of both regular season and playoffs for this season.
Then, the results are saved in local for future usage.

```python
    def get_nhl_data(self, start_season, end_season):
        """Return the NHL play-by-play data between two seasons.

        :param start_season: start season (start_season/start_season+1)
        :type a: int
        :param end_season: end season (end_season/end_season+1)
        :type b: int

        :rtype: list
        :return: NHL play-by-play data of all seasons between start_season and end_season
        """
        progress_bar = tqdm(range(start_season, end_season + 1))
        data = []
        for season in progress_bar:
            progress_bar.set_description(f'Retrieving NHL data for season {season}/{season + 1}')
            data.extend(self.get_nhl_season(season))
            progress_bar.set_description(f'Data saved to {self.DATASET_DIR_PATH}')

        return data


    def get_nhl_season(self, season):
        """Return the NHL play-by-play data for one season (regular season and playoffs)

        :param season: season (season/season+1)
        :type a: int

        :rtype: list
        :return: NHL play-by-play data of season/season+1
        """

        filepath = os.path.join(self.DATASET_DIR_PATH, f'data-{season}.npy')

        # check if the data already exists in local
        if os.path.exists(filepath):
            return np.load(filepath, allow_pickle=True)

        data = []
        data.extend(self.get_nhl_regular(season))
        data.extend(self.get_nhl_playoffs(season))

        # save the data in local for next usage     
        np.save(filepath, data)

        return data
```

The code below illustrates how we retrieved the data for both *regular season*  and *playoffs*.

The method ```get_nhl_regular```  goes through the game ids of the regular season and retrieves the data of each game.
In regular seasons, a game id has the following format:

<figure >
    <img src="/assets/Question2_1.png" style="width:40%; margin:auto;">
    <figcaption style="text-align:center;">Figure 2.1: Format of the game id for regular seasons</figcaption>
</figure>

The method ```get_nhl_playoffs```  goes through the game ids of the playoffs and retrieves the data of each game.
In playoffs, a game id has the following format:

<figure >
    <img src="/assets/Question2_2.png" style="width:40%; margin:auto;">
    <figcaption style="text-align:center;">Figure 2.2: Format of the game id for playoffs</figcaption>
</figure>

```python
    def get_nhl_regular(self, season, game_type = 2):
        """Retrieve and return the NHL play-by-play data for a regular season.

        :param season: season (season/season+1)
        :type a: int
        :game_type: type index of regular season in the NHL Stats API 
        :type a: int

        :rtype: list
        :return: NHL play-by-play data of regular season (season/season+1)
        """

        nb_games = 868 if season == 2020 else 1271 if season > 2016 else 1230
        data=[]

        for i in range(nb_games):
            game_id = f'{season}{game_type:02}{i+1:04}'
            url = f'https://statsapi.web.nhl.com/api/v1/game/{game_id}/feed/live/'
            response = requests.get(url)

            if(response.status_code != 200):
                raise Exception('Error occured while retrieving data from NHL api!')

            data.append(response.json())
        return data


    def get_nhl_playoffs(self, season, game_type = 3): 
        """Retrieve and return the NHL play-by-play data for the playoffs of season/season+1.

        :param season: season (season/season+1)
        :type a: int
        :game_type: type index of playoffs in the NHL Stats API 
        :type a: int

        :rtype: list
        :return: NHL play-by-play data of playoffs (season/season+1)
        """

        data=[]
        nb_rounds = 4
        nb_games = 7

        for iround in range(nb_rounds):
            for matchup in range(pow(2, 3 - iround)):
                for game in range(7):
                    game_id = f'{season}{game_type:02}0{iround+1}{matchup+1}{game+1}'
                    url = f'https://statsapi.web.nhl.com/api/v1/game/{game_id}/feed/live/'
                    response = requests.get(url)

                    if(response.status_code != 200):          
                        continue

                    data.append(response.json())
        return data
```


Figure 2.3 illustrates an example of usage of our **NHL_API** module.

<figure >
    <img src="/assets/Question2_3.png" style="width:100%; margin:auto;">
    <hr>
    <img src="/assets/Question2_4.png" style="width:100%; margin:auto;">
    <figcaption style="text-align:center;">Figure 2.3: An example of usage of our NHL API module</figcaption>
</figure>

In this example, we extract the data from the 2016-17 season all the way up to the 2020-21 season.
For each season, if the data exists in local, then we simply read and return it. 
Otherwise, we retrieve it from the NHL API and we save it in local for future usage.
The path to the local dataset is given by the environment variable ```DATASET_DIR_PATH```.


## Task 3: Interactive Debugging Tool

## Task 4: Tidy Data
#### Question 1
**In your blog post, include a small snippet of your final dataframe (e.g. using head(10)). You can just include a screenshot rather than fighting to get the tables neatly formatted in HTML/markdown.**

<figure>
<img src="/assets/Question4_1.png" alt="">
<figcaption style="text-align:center;">Figure 4.1: First 10 rows of tidy data</figcaption>
</figure>

#### Question 2
**You’ll notice that the “strength” field (i.e. even, power play, short handed) only exists for goals, not shots. Furthermore, it doesn’t include the actual strength of players on the ice (i.e. 5 on 4, or 5 on 3, etc). Discuss how you could add the actual strength information (i.e. 5 on 4, etc.) to both shots and goals, given the other event types (beyond just shots and goals) and features available. You don’t need to implement this for this milestone.**

Let's say there is an event that causes an imbalance of strength.
In such a cause, the information regarding strength disparity and the current players per team in the rink could be stored and used to populate the information in the coming events.
If an event brings back the strength to even, this new information is used for the following events.
This way, any event will know the current strenght and number of players at that given time. 

#### Question 3
**In a few sentences, discuss some additional features you could consider creating from the data available in this dataset. We’re not looking for any particular answers, but if you need some inspiration, could a shot or goal be classified as a rebound, or a shot off the rush?**

I would add an event for own goals. This type of even is rare but it happens (A compilation of own goals in the NHL is available <p><a href="https://www.youtube.com/watch?v=AyczU_hy78k&t=323s&ab_channel=DeltaHighlights">here!</a></p>).
I would also attempt to make each event more uniform by making them have the same fields. For example, instead of not having a field "empty net" for 'Shot' events, it could have "empty_net: nan". Considering the concept of making new classifications for shots and goals, I would go as far as changing all 'Goal' events to be 'Shot' events, and shots that are goals would be a subset of this type of event.

## Task 5: Simple Visualizations 

## Task 6: Advanced Visualizations: Shot Maps

